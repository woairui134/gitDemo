# coding=utf-8
# d={"a":24,"g":52,"i":12,"k":33}
# # b=a.reverse()
# # print(len(a))
# d.reverse()
# print(d)
# a='我是十个字的长字符'


# # b=a[-6:-2]
# # print(b)
# b=a[1:6:2]
# print(b)
# #
# # a= [ 'runoob', 786 , 2.23, 'john', 70.2 ]
# # c= ('runoob', 786 , 2.23, 'john', 70.2 )
# # # print(a[1:4])
# # a[2]=999 #列表可以重新赋值
# # print(a)
# # c[2]=999 #元祖只读不能改
# # print(c)
#
#
# # !/usr/bin/python
# # -*- coding: UTF-8 -*-
# #
# # a = {}
# # a['one'] = "This is one"
# # a[2] = "This is two"
# #
# # b = {'name': 'runoob', 'code': 6734, 'dept': 'sales'}
# #
# # print(a['one'])
# # print(a[2])
# # print(b)
# # print(b.keys())
# # print(b.values())
# # b[a['one']]=a[2] # 字典是无顺序放，直接写就行
# # print(b)
# # a = 1
# # b = 2
# # print(type(str(a)))  类型查询
# # print(a+b)
# # print(a-b)
# # print(a*b)
# # print(a/b)
# # print(b%a)  #余数
# # # print(a//b)
# # a = 0
# # b = 10
# # if a and b:
# #     print("a和b都为true")
# # else:
# #     print("a和b有一个不为true")
# #
# # if a or b:
# #     print("a和b都为true,或其中一个为true")
# # else:
# #     print("a和b都不为true")
# #
# # if not(a and b):
# #     print("a和b都为false,或其中一个为false")
# # else:
# #     print("a和b都为true")
#
# # a = 10
# # b = 13
# # c = [1,2,3,4,7,10,32,44]
# #
# # if a in c :
# #     print("a在c中")
# # else:
# #     print("no")
# #
# # if b not in c :
# #     print("B不在c中")
# # else:
# #     print("b在c中")
#
# # a = 10
# # b = 15
# # c = "10"
# # d = int(c)
# # if a is b:
# #     print("a和b有相同的标识")
# # else:
# #     print("a和b没相同标识")
# #
# # if a is d:
# #     print("a和d有相同的标识")
# # else:
# #     print("a和d没相同标识")
#
# # a = 30
# # b = 15
# # c = 10
# # d = 5
# # e = 0
# #
# # e = (a + b) * c / d  # ( 45 * 10 ) / 5
# # print("(a + b) * c / d 运算结果为：", e)
#
# # a = 8
# # if (a>=0 and a<=7) or (a>=10 and a<=15):
# #     print("a在0-7和10-15之间")
# # else:
# #     print("a不在0-7和10-15之间")
#
# # i =2
# # while i<11 :
# #     i += 1
# #     if i%2 > 0:
# #         continue
# #     print(i)
# #
# # i = 1
# # while i:
# #     i+=1
# #     if i >10:
# #         break
# #     print(i)
#
# # for a in '叽叽喳喳哈':
# #     print(a)
#
# # a = ['aaa',111,'bbb','哈哈']
# # for b in a:
# #     print(b)
#
# # for a in range(10,20):
# #     for i in range(2,a):
# #         if a%i == 0:
# #             b = a/i
# #             print('%d 等于 %d * %d' % (a,i,b))
# #             break
# #     else:
# #         print(a)
#
# # i = 2
# # while(i<100):
# #     b = 2
# #     while(b <= (i/b)):
# #         if not(i%b):
# #             break
# #         b = b + 1
# #     if (b >i/b):
# #        print(i, "是素数")
# #     i += 1
#
# # for a in 'python':
# # #     if a  == 't':
# # #         break  #条件达到则退出，不往下执行
# # #     print('当前字母：',a)
#
#
# # for a in 'python':
# #     if a == 'h':
# #         continue  # 条件达到就跳过继续往下执行
# #     print(a)
# #
# # var1 = 'Hello World!'
# # # print("输出 :- ", var1[:6] + 'Runoob!')
# # a= "python"
# # if("H" in a):
# #     print("true")
# # else:
# #     print("false")
#
# # print("My name is %s and weight is %d%c kg!" % ('Zara', 21, 99))
#
#
# # a={'a1':1,'b1':2,'c1':3,'d1':4,'c2':5,'c3':6,'b2':7}
# # a1=['2121212.121','45454.4545','123213213213','2321321312','323213','3232324','32132144214.56','2421551']
# # a2 = ['1.dat','10.dat','5.dat']
#
# # #字典转为列表
# # b = list(a.keys())
# # c = list(a.values())
# # print(b+c)
#
# # # d = b.sorted(key= lambda i:int(re.match(r'(\b+),i').group()))
# # #数字排序-升序
# # c.sort(reverse=True)
# # print(c)
# #
# # #字母排序-['a1', 'b1', 'b2', 'c1', 'c2', 'c3', 'd1']
# # b.sort(reverse=False)
# # print(b)
# #
# # #小数和字符串比较
# # a1.sort(reverse=True)
# # print(a1)
#
# # # 没弄出来
# # from typing import re
# # a2 = ['1.dat','10.dat','5.dat']
# # #字符串比较
# # a2.sort(key = lambda i:int(re.Match(r'(\d+)',i).group()))
# # print(a2)
#
# # basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
# # # print(basket)  # 这里演示的是去重功能-集合输出后会排重
# # print('ades' in basket) #判断字符串是都在集合内
# # print('pear' in basket)
# #
# # a = set('qwerqwe123456op')
# # b = set('qwsada1253wwe')
# # # print(a)
# # print(a-b)  # 集合a中包含而集合b中不包含的元素
# # print(a|b)  # 集合a或b中包含的所有元素
# # print(a&b)  # 集合a和b中都包含了的元素
# # print(a^b)  # 不同时包含于a和b的元素a
#
# # a = set(('a','b','c'))
# # # a.add('d')
# # # print(a)
# # a.update(["积极","哈哈"],[1,4])
# # print(a)
# #
# # a = set((1, '哈哈', 4, 'b', 'a', '积极', 'c',1,2))
# # a.remove("哈哈哈")  #未找到元素则报错：KeyError: '哈哈哈'
# # a.remove("哈哈")
# # print(a)
#
# # a = set((1, '哈哈', 4, 'b', 'a', '积极', 'c',1,2))
# # # a.discard('哈哈哈')   # 找不到元素不会报错，
# # a.discard('哈哈')
# # print(a)
#
#
# # a = set((1,'哈哈',4,'b','a','积极','c',1,2,9))
# # a = set((1,2,3,4,5,6,7,8,9))
# # a.pop()  #随机删除列表内数据
# # print(a)
# # print(len(a))   #查询元素个数，重复的元素只计算1个
#
# # a = set((1,'哈哈',4,'b','a','积极','c',1,2,9))
# # a.clear()   #清空所有元素
# # # print(a)
# #
# # a = set((1,'哈哈',4,'b','a','积极','c',1,2,9))
# # print('b1' in a)  # 判断元素是否在集合中
#
# # # 斐波纳契数列
# # a,b = 0,1
# # while b < 10:
# #     print(b)   # 1,1 ,3,5,8,13
# #     # print("a的参数："+a)
# #     a,b = b,a+b
#
# # # 斐波纳契数列
# # a,b = 0,1
# # while b < 10:
# #     print(b)   # 1,1 ,3,5,8,13
# #     # print("a的参数："+a)
# #     a,b = b,a+b
#
# # a,b = 0,1
# # while b < 1000:
# #     print(b ,end=',')  #1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,
# #     a,b = b, a+b
# #
# # a = int(input("请输入你家狗狗的年龄："))
# # print("")
# # if a <= 0:
# #     print("不能输入空")
# # elif a == 1:
# #     print("相当于14岁的人")
# # elif a == 2:
# #     print("相当于22岁的人")
# # elif a > 2:
# #     b = 22+(a-2)*5
# #     print("对应人类年龄："+b)
# # input("点击退出")
# #
# # n = 100
# # a,b = 0,1
# # while b<= n:
# #     a = a+b
# #     b = b+1
# #     #print(n, a)  # 内层输出所有结果
# # print(n,a)  # 外层只要最后结果
#
# # a = [1,2,3,4,5]
# # b = iter(a)
# # # print(next(b))
# #
# # a= [1,2,3,4,5,6]
# # b = iter(a)
# # for c in b:
# #     print(c,end=',')
#
# # class CX:
# #     def __iter__(self):
# #         self.a = 1
# #         return self
# #
# #     def __next__(self):
# #         if self.a <= 20:
# #             b = self.a
# #             self.a += 1
# #             return b
# #         else:
# #             raise StopAsyncIteration    #StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况，
# #                                         # 在 __next__() 方法中我们可以设置在完成指定循环次数后触发 StopIteration 异常来结束迭代。
# #
# # myclass = CX()
# # myiter = iter(myclass)
# #
# # for x in myiter:
# #     print(x)
#
# # import sys
# #
# # def fibonacci(n):  #生成器函数
# #     a,b,c = 0,1,0
# #     while True:
# #         if(c > n):
# #             return
# #         yield  a   #
# #         a,b = b,a+b
# #         c +=1
# # f = fibonacci(10) #  f 是一个迭代器，由生成器返回生成
# #
# # while True:
# #     try:
# #         print(next(f),end=' ')    # f迭代中返回yield a的结果参数
# #     except StopAsyncIteration:
# #         sys.exit()
#
#
# # 归纳，yield在一段代码执行或循环中，会保留该参数，并且下次是从带入参数位置继续循环，
# # 例如：1234，执行yield 会输出1，2，3，4，而不是1，12，123，1234
# # yield: 好处：1.不会将所有数据取出来存入内存中；而是返回了一个对象；可以通过对象获取数据；用多少取多少，可以节省内容空间。
# #2.除了能返回一个值，还不会终止循环的运行； yield item.get('article_url')
#
# # def a():
# # #     print('1')
# # #     x = yield 'hello'  # 第一次输出
# # #     print('2','x=',x)  # 第二次输入，只取值了第二次的 send（5）
# # #     y = 5+(yield x)
# # #     print('3','y=',y)  # 第三次输入，只取值了第三次的send（2）
# # # f = a()
# # # print(f.__next__())
# # # print(f.send(5))
# # # print(f.send(2))
#
# # def a(b):
# #     print(b)
# #     return
# # print("调用函数")
# # print("再次调用函数")
#
# # def a(b):
# #     print(id(b))
# #     b = 10
# #     print(id(b))
# # b = 1
# # print(id(b))
# # a(b)
#
# # def a(b):
# #     b.append([1,2,3,4])
# #     print("函数内取值：",b)
# #     return
# # b = [10,20,30,40]
# # a(b)
# # print("函数外取值：",b)
#
# # def a(b,c):
# #     print("姓名：",b)
# #     print("年龄：",c)
# #     return
# # a(c=23,b="嘻嘻")
#
# # def a(name,age=16):
# #     print("姓名：",name)
# #     print("年龄：",age)
# #     return
# # a(name="嘎嘎",age=19)
# # print ("------------------------")
# # a(name="嘎嘎")
#
# a = [44.23,444,666.1,5783,444,444]
# print(a.count(444))  #该444元素出现的次数
#
# a = [22.22,10.1,44,-99,-21,0]
# b = a.sort()
# print(b)          # sort是没有返回值的，他只是改变了a的原来顺序，所以输出为空
# print(a.sort())   # sort是没有返回值的，他只是改变了a的原来顺序，所以输出为空
# print(a)
#
# a = [3,4,5]
# print([2*x for x in a] )
# print([[x,3*x] for x in a])

# a = ['bba','ccsde','ppudj']
# print([x.strip() for x in a ])

# a = [1,8,9]
# print([3*x for x in a if x >3])
# a1 = [3,6,9,5]
# a2 = [2,4,-8,-1]
# # print([x*y for x in a1 for y in a2])
# print([a1[i]*a2[i] for i in range(len(a1))])  # 意思是根据a1的长度以此取出i的值并且根据i的值，取a1和a2的位置值并相乘
#
# a = [str(round(1/3,i)) for i in range(0,6)]
# print(a)
#
# a = [
#     [1,2,3,4,14],
#     [5,6,7,8,15],
#     [9,10,11,12,16],
#     [66,44,77]
# ]
# # b = [[c[i] for c in a] for i in range(3)]
# # print(b)
#
# d = []
# for i in range(3):
#     d.append([d[i] for d in a])
# print(d)
#
# a = [-1,1,2,3,4,5,6,7,8,9]
# # del a[0]    # 删除值
# # print(a)
#
# print(a.pop(0))  #取值
#
# a = {'gallahad': 'the pure', 'robin': 'the brave'}
# for k,v in a.items():
#     print(k,v)
#
# a = ['tic','tac','toc']                    # i       v
# for i,v  in enumerate(a):   #在序列中遍历时，索引位置和对应值可以使用 enumerate() 函数同时得到：
#     print(i,v)
#
#
# a = ['tic','tac','toc']
# for i in enumerate(a):
#     print(i)
#
# a = ['name', 'quest', 'favorite color']
# b = ['lancelot', 'the holy grail', 'blue']
# for e,r in zip(a,b):
#     # print("序号:"+e,"数值："+r)
#     print('what is you {0}? it is {1}'.format(e,r))

# a = range(1,20,3)
# for i in reversed(a):
#     print(i)

# a = [i*j for i in range(1,5)  for j in range(1,4)]
# print(a)
# a=[]
# for i in range(1,5):
#     for j in range(1,5):
#         a.append(i*j)
# print(a)

# a=(1,2,3,4)
# b=1,2,3,4
#
# print("a",a)
# print(type(a))

# a ={1,2,3}
# b ={3,4,5}
# print(a.union(b))    #并集
# print(a.intersection(b))    #差集
# print(a.difference(b))
# c ="ajsdjahjashdeussdad";
# print(set(c))

# a ="abcdefghigk"
# # 前闭后开原则，1≤X＜7
# #开始位置：结束值的前一位：步长（就是前一位和最后取值的间隔数-1）
# print(a[1:7:2])

# a = [1,2,3,4,5,6,7,"a","b",True]
# # # 前闭后开原则，1≤X＜7
# # #开始位置：结束值的前一位：步长（就是前一位和最后取值的间隔数-1）
# print(a[2:5:2])
#
# f = open('data.txt')
# # print(f.readable())
# # print(f.readlines()) # 全部    表格大数据不建议使用
# print(f.readline())  # 单行读取
# print(f.readline())  # 单行读取
# print(f.readline())  # 单行读取
# f.close()

# with 语句块，可以将文件打开之后，操作完毕后自动关闭文件
# 图片读取需要使用 rb   读取二进制格式文件
# 正常文本模式 直接使用默认的rt即可
# with open('data.txt') as f:
#     while True:
#         line = f.readline()
#         if line:
#             print(line)
#         else:
#             break
#     # print(f.readlines())

# coding=utf-8
# 错误与异常的区别
# try:
#     num1 = int(input("输入一个除数"))
#     num2 = int(input("属于一个被除数"))
#     print(num1/num2)
# # except ZeroDivisionError:
# #     print("被除数不能为0")
# # except ValueError:
# #     print("输入的需要是数值型整数")
# except:
#     print("这是一个能用型异常")
# # else:
# #     print("程序正常")
# finally:
#     print("无论有没有异常都执行")
# x=10
# if x>5:
#     raise Exception("这是抛出的异常")
#
# class myException(Exception):
#     def __init__(self,a,b):
#         self.a = a
#         self.b = b
# raise myException("a","b")


# -*- coding: utf-8 -*-

# 创建一个人类
# 通过class 关键字 进行定义一个类
class person:
    name = "default"   # 类变量
    age = 0
    gender = 'male'
    weight = 0

    # 构造方法，在实例化的时候被调用
    def __init__(self,name,age,gender,weight):
        # self.name   是实例变量，每一个实力都有自己的属性
        self.name = name
        self.age = age
        self.gender = gender
        self.weight = weight



    # def fuzhi(self,name,age,gender,weight):
    #     self.name = name
    #     self.age = age
    #     self.gender =gender
    #     self.weight = weight

    @classmethod    #类实例方法装饰器
    def eat(self):
        print(f"{self.name} is eating")

    def play(self):
        print(f"{self.name} is playing")

    def jump(self):
        print(f"{self.name} is jump")


# 类方法和实力方法区别
# 类方法不能访问 实例方法
# 类方法 需要添加classmenthod装饰器

person.eat()
# zs = person("tom",32,'man',95)
# zs.eat()
#类变更 和实例变量的区别
# 类变量是需要类 来访问的，实力变量需要实例来访问
#
# print(person.name)
# person.name ='xixi'
# print(person.name)
#
# zs = person("tom",32,'man',95)
# print(zs.name)
# zs.name ='lili'
# print(zs.name)


# # 类的实例化，创建了一个实力
# zs = person("tom",32,'man',95)
# # zs.fuzhi("tom",32,'man',95)
# print(f"(zhangsan的姓名是{zs.name},zhangsan的年龄是:{zs.age},zhangsan的性别：{zs.gender}")
# zs.eat()
#
# ls = person("lisi",33,'man',130)
# # zs.fuzhi("tom",32,'man',95)
# ls.jump()
# print(f"(zhangsan的姓名是{ls.name},zhangsan的年龄是:{ls.age},zhangsan的性别：{ls.gender}")

# -*- coding: utf-8 -*-
# python的常用库

# os模块主要是针对文件，目录的操作
# 常用方法：
# os.mkdir() 创建目录
# os.removedirs ()  删除文件
# os.getcwd()  获取当前目录
# os.path.exists（dir or  file ） 判断文件或目录是否存在

import  os
# os.mkdir("testdir")
# print(os.listdir("./"))    #等于 ls查询
# os.removedirs("testdir")
# print(os.getcwd())

# print(os.path.exists("b"))     #判断文件或目录是否存在
# if not os.path.exists("b"):
#     os.mkdir("b")
# if not os.path.exists("b/test.txt"):
#     f = open("b/test.txt","w")
#     f.write("hello, os using")
#     f.close()


import time
# time模块是获取当前时间及时间格式经的模块
# time.asctime()    国外的时间格式
# time.time()   时间戳
# time.sleep（）  强等待
# time.localtime()  时间戳转成时间元组
# time.strftime()   将当前时间戳转成带格式的时间
# 格式：time.strftime("%Y-%m-%d %H:%M:%S",time.localtime())


# print(time.asctime())
# print(time.time())
# print(time.localtime())
# print(time.strftime("%Y-%m-%d %H:%M:%S", time.localtime()))

#获取2天前的现在时间
# now_time = time.time()
# two_time = now_time - 60*60*24*2
# time_tuple = time.localtime(two_time)
# print(time.strftime("%Y-%m-%d %H:%M:%S",time_tuple))

# # 获取三天后的当前时间
# time1 = time.time()
# time2 = time1 + 60*60*24*3
# # time3 = time.localtime(time2)
# print(time.strftime("%Y-%m-%d %H:%M:%S",time.localtime(time2)))



# urllib  网络请求库

# python2
# import urllib2
# response = urllib2.urlopen("http://www.baidu.com")

# python3
# import urllib.request
# response = urllib.request.urlopen("http://www.baidu.com")

# import urllib.request
#
# response = urllib.request.urlopen("http://www.baidu.com")
# print(response.status)   # 返回接口状态
# print(response.read())   # read() 返回的是接口的响应数据
# print(response.headers())   # read() 返回的是接口的响应数据

# import requests
# r = requests.get("http://www.baidu.com")
# print(r.status_code)
# print(r.headers)

# math 库  科学计数法
import math
# math.ceil(x)      #返回大于等于参数X的最小整数
# math.floor(x)     #返回小于等于参数X的最大整数
# math.sqrt(x)      #x的平方根

print(math.ceil(5.5))
print(math.floor(5.5))
print(math.sqrt())

# -*- coding: utf-8 -*-
# python 多线程
# ptrhon 使用 解释器 进行主循环
# 主循环中只有一个控制线程在执行
# 使用全局解释器锁（GIL）保证只有线程在执行
# 通过设置GIL

# python 两种线程管理
# _thread      :提供了基本的线程和锁
# threading    :提供了更高级别、功能更权限的线程管理
# threading 使用了_thread 的底层并进行强化处理
#   --支持同步机制
#   --支持守护线程
import _thread
import logging
import threading
from time import sleep, ctime
logging.basicConfig(level=logging.INFO)


# def loop0():
#     logging.info("start loop0  at"+ctime())
#     sleep(4)
#     logging.info("end loop0  at"+ctime())
#
#
# def loop1():
#     logging.info("start loop1  at"+ctime())
#     sleep(2)
#     logging.info("end loop1  at"+ctime())

# _thread方法，所有主线结束后  子线程强制被杀死，所以main主线程下添加了6秒等待
# def main():
#     logging.info("start all at"+ctime())
#     _thread.start_new_thread(loop0,())
#     _thread.start_new_thread(loop1,())
#     sleep(6)
#     logging.info("end all at"+ ctime())
#
#
# if __name__ == '__main__':
#     main()


# loops=[2,4]
# def loop(nloop,nsec,lock):    # nloop表示第几个loop，nsec表示时间，lock表示锁
#     logging.info("start loop" + str(nloop) +  "at" + ctime())
#     sleep(nsec)
#     logging.info("end loop" + str(nloop) +  "at" + ctime())
#
#     lock.release()
#
# def main():
#     logging.info("start all at"+ctime())
#     locks=[]
#     nloops = range(len(loops))
#
#     for i in nloops:
#         lock = _thread.allocate_lock()    # _thread.allocate_lock() 声明一个锁
#         lock.acquire()   # 加锁
#         locks.append(lock)
#     #   _thread.start_new_thread(loop,(i,loops[i],locks[i])) 为什么不在循环内
#     # 因为获取锁 需要时间，所以不把新开子线程加载在声明锁的循环内
#
#     for i in nloops:
#         _thread.start_new_thread(loop,(i,loops[i],locks[i]))
#
#     for i in nloops:
#         while locks[i].locked():
#             pass
#
#     logging.info("end all at"+ ctime())
#
#
# if __name__ == '__main__':
#     main()



# loops=[2,4]
# def loop(nloop,nsec):    # nloop表示第几个loop，nsec表示时间，lock表示锁
#     logging.info("start loop " + str(nloop) +  "at" + ctime())
#     sleep(nsec)
#     logging.info("end loop " + str(nloop) +  "at" + ctime())
#
#
# def main():
#     logging.info("start all at"+ctime())
#     nloops = range(len(loops))
#     threads = []
#     for i in nloops:
#         t = threading.Thread(target=loop,args=(i,loops[i]))
#         threads.append(t)
#     for i in nloops:
#         threads[i].start()
#     for i in nloops:
#         threads[i].join()    # join方法，判断thread[i]是否完成，如果没完成则等待，如果完成则释放解除等待
#     logging.info("end all at"+ ctime())
#
#
# if __name__ == '__main__':
#     main()


loops=[2,4]


class mythreads(threading.Thread):
    def __init__(self,func,args,name=''):
        threading.Thread.__init__(self)
        self.func = func
        self.args = args
        self.name = name

    def run(self):
        self.func(*self.args)

def loop(nloop,nsec):    # nloop表示第几个loop，nsec表示时间，lock表示锁
    logging.info("start loop " + str(nloop) +  "at" + ctime())
    sleep(nsec)
    logging.info("end loop " + str(nloop) +  "at" + ctime())


def main():
    logging.info("start all at"+ctime())
    nloops = range(len(loops))
    threads = []
    for i in nloops:
        t = mythreads(loop,(i,loops[i]),loop.__name__)
        threads.append(t)
    for i in nloops:
        threads[i].start()
    for i in nloops:
        threads[i].join()    # join方法，判断thread[i]是否完成，如果没完成则等待，如果完成则释放解除等待

    logging.info("end all at"+ ctime())


if __name__ == '__main__':
    main()

#   原语
##  锁
##  信号量

# -*- coding: utf-8 -*-
# python的常用三方库
##   pytest
# ##   requests
# import  requests
# # requests详解：https://zhuanlan.zhihu.com/p/93763746
# # r = requests.get("http://www.baidu.com")
#
# r = requests.post('http://httpbin.org/post',data = {'key':'value'})
# print(r.text)
# print(r.status_code)
# r.encoding
# r.status_code
# r.encoding="utf-8"

# YAML 是一个可读性高，用来表达数据序列化的格式，常常作为配置文件用
# json 是一个醒来那个街的数据交换语言，该语言以易于阅读的文字基础，用来传输有属性值或者序列性的值组成数据对象
# EXCEL 有直观界面，出色的计算功能和图标工具是一款电子制表软件

from openpyxl import Workbook
from openpyxl.utils import get_column_letter


# write a worbook   创建一个文件并写入
# wb = Workbook()
# dest_filename = 'empty_book.xlsx'
#
# ws1 = wb.active
# ws1.title = "range names"
#
# for row in range(1, 40):
#     ws1.append(range(600))
#
# ws2 = wb.create_sheet(title="Pi")
#
# ws2['F5'] = 3.14
#
# ws3 = wb.create_sheet(title="Data")
# for row in range(10, 20):
#     for col in range(27, 54):
#         _ = ws3.cell(column=col, row=row, value="{0}".format(get_column_letter(col)))
# print(ws3['AA10'].value)
#
# ws4 = wb.create_sheet(title="my_sheet")
# for i in range(1,31):
#     ws4.cell(column=1,row=i).value="test"
#
# wb.save(filename = dest_filename)


# # Read an existing workbook  读文件
# from openpyxl import load_workbook
# wb = load_workbook(filename = 'empty_book.xlsx')
# sheet_ranges = wb['range names']
# print(sheet_ranges['D18'].value)
#
# for i  in range(1,31):
#     print(sheet_ranges.cell(column=1, row=i).value)

# pyyaml 详解：https://blog.csdn.net/swinfans/article/details/88770119

import yaml

# print(yaml.load("""
#  - Hespriidea
#  - Papilionidea
#  - Apatelodidea
#  - Epiplemidea
#  """,Loader=yaml.CFullLoader))

# print(yaml.load("""
# # a: 1
# #  """,Loader=yaml.CFullLoader))


# print(yaml.load(open("demoyaml.yaml"),Loader=yaml.CFullLoader))  #  load是把yaml变成python的格式

with open("demo1yaml.yaml","w") as f:
        yaml.dump(data= {'a':[1,3]},stream= f)  # dump 是把python变成yaml的格式








